import { Inject, Injectable, PLATFORM_ID, Optional } from '@angular/core';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { coerceElement } from '@angular/cdk/coercion';
import { getRtlScrollAxisType } from '@angular/cdk/platform';
import { fromEvent, merge, of, Observable, Subject, animationFrameScheduler } from 'rxjs';
import { expand, finalize, take, takeUntil, takeWhile } from 'rxjs/operators';
import BezierEasing from 'bezier-easing';
import { SMOOTH_SCROLL_OPTIONS } from './smooth-scroll.model';
import * as i0 from "@angular/core";
// @dynamic
export class SmoothScrollManager {
    get _w() {
        return this._document.defaultView;
    }
    /**
     * Timing method
     */
    get _now() {
        return this._w.performance && this._w.performance.now
            ? this._w.performance.now.bind(this._w.performance)
            : Date.now;
    }
    constructor(_document, _platform, customDefaultOptions) {
        this._document = _document;
        this._platform = _platform;
        // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.
        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.
        // Purpose: If user called a scroll function again on the same element before the scrolls completes,
        // it cancels the ongoing scroll and starts a new one
        this._onGoingScrolls = new Map();
        this._defaultOptions = {
            duration: 468,
            easing: {
                x1: 0.42,
                y1: 0,
                x2: 0.58,
                y2: 1
            },
            ...customDefaultOptions,
        };
    }
    /**
     * changes scroll position inside an element
     */
    _scrollElement(el, x, y) {
        el.scrollLeft = x;
        el.scrollTop = y;
    }
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     */
    _getElement(el, parent) {
        if (typeof el === 'string') {
            return (parent || this._document).querySelector(el);
        }
        return coerceElement(el);
    }
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     */
    _initSmoothScroll(el) {
        if (this._onGoingScrolls.has(el)) {
            this._onGoingScrolls.get(el).next();
        }
        return this._onGoingScrolls.set(el, new Subject()).get(el);
    }
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     */
    _isFinished(context, destroyed, resolve) {
        if (context.currentX !== context.x || context.currentY !== context.y) {
            return true;
        }
        destroyed.next();
        resolve();
        return false;
    }
    /**
     * Terminates an ongoing smooth scroll
     */
    _interrupted(el, destroyed) {
        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));
    }
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     */
    _destroy(el, destroyed) {
        destroyed.complete();
        this._onGoingScrolls.delete(el);
    }
    /**
     * A function called recursively that, given a context, steps through scrolling
     */
    _step(context) {
        return new Observable((subscriber) => {
            let elapsed = (this._now() - context.startTime) / context.duration;
            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;
            // apply easing to elapsed time
            const value = context.easing(elapsed);
            context.currentX = context.startX + (context.x - context.startX) * value;
            context.currentY = context.startY + (context.y - context.startY) * value;
            this._scrollElement(context.scrollable, context.currentX, context.currentY);
            // Proceed to the step
            animationFrameScheduler.schedule(() => subscriber.next(context));
        });
    }
    _applyScrollToOptions(el, options) {
        if (!options.duration) {
            this._scrollElement(el, options.left, options.top);
            return Promise.resolve();
        }
        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled
        const destroyed = this._initSmoothScroll(el);
        const context = {
            scrollable: el,
            startTime: this._now(),
            startX: el.scrollLeft,
            startY: el.scrollTop,
            x: options.left == null ? el.scrollLeft : ~~options.left,
            y: options.top == null ? el.scrollTop : ~~options.top,
            duration: options.duration,
            easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)
        };
        return new Promise(resolve => {
            // Scroll each step recursively
            of(null).pipe(expand(() => this._step(context).pipe(takeWhile((currContext) => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();
        });
    }
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param scrollable element
     * @param customOptions specified the offsets to scroll to.
     */
    scrollTo(scrollable, customOptions) {
        if (isPlatformBrowser(this._platform)) {
            const el = this._getElement(scrollable);
            const isRtl = getComputedStyle(el).direction === 'rtl';
            const rtlScrollAxisType = getRtlScrollAxisType();
            const options = {
                ...this._defaultOptions,
                ...customOptions,
                ...{
                    // Rewrite start & end offsets as right or left offsets.
                    left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,
                    right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right
                }
            };
            // Rewrite the bottom offset as a top offset.
            if (options.bottom != null) {
                options.top = el.scrollHeight - el.clientHeight - options.bottom;
            }
            // Rewrite the right offset as a left offset.
            if (isRtl && rtlScrollAxisType !== 0 /* RtlScrollAxisType.NORMAL */) {
                if (options.left != null) {
                    options.right = el.scrollWidth - el.clientWidth - options.left;
                }
                if (rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {
                    options.left = options.right;
                }
                else if (rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {
                    options.left = options.right ? -options.right : options.right;
                }
            }
            else {
                if (options.right != null) {
                    options.left = el.scrollWidth - el.clientWidth - options.right;
                }
            }
            return this._applyScrollToOptions(el, options);
        }
        return Promise.resolve();
    }
    /**
     * Scroll to element by reference or selector
     */
    scrollToElement(scrollable, target, customOptions = {}) {
        const scrollableEl = this._getElement(scrollable);
        const targetEl = this._getElement(target, scrollableEl);
        const options = {
            ...customOptions,
            ...{
                left: targetEl.offsetLeft + (customOptions.left || 0),
                top: targetEl.offsetTop + (customOptions.top || 0)
            }
        };
        return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();
    }
}
SmoothScrollManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: SmoothScrollManager, deps: [{ token: DOCUMENT }, { token: PLATFORM_ID }, { token: SMOOTH_SCROLL_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
SmoothScrollManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: SmoothScrollManager, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: SmoothScrollManager, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [SMOOTH_SCROLL_OPTIONS]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic21vb3RoLXNjcm9sbC1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXNjcm9sbGJhci9zbW9vdGgtc2Nyb2xsL3NyYy9zbW9vdGgtc2Nyb2xsLW1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFjLE1BQU0sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN0RixPQUFPLEVBQUUsUUFBUSxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDOUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3RELE9BQU8sRUFBRSxvQkFBb0IsRUFBcUIsTUFBTSx1QkFBdUIsQ0FBQztBQUVoRixPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBYyx1QkFBdUIsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0RyxPQUFPLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzlFLE9BQU8sWUFBWSxNQUFNLGVBQWUsQ0FBQztBQUN6QyxPQUFPLEVBQ0wscUJBQXFCLEVBS3RCLE1BQU0sdUJBQXVCLENBQUM7O0FBRS9CLFdBQVc7QUFJWCxNQUFNLE9BQU8sbUJBQW1CO0lBVzlCLElBQVksRUFBRTtRQUNaLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUM7SUFDcEMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBWSxJQUFJO1FBQ2QsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxHQUFHO1lBQ25ELENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENB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LEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNsRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQztRQUN4RCxNQUFNLE9BQU8sR0FBMEI7WUFDckMsR0FBRyxhQUFhO1lBQ2hCLEdBQUc7Z0JBQ0QsSUFBSSxFQUFFLFFBQVEsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxhQUFhLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQztnQkFDckQsR0FBRyxFQUFFLFFBQVEsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxhQUFhLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQzthQUNuRDtTQUNGLENBQUM7UUFDRixPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUM3RSxDQUFDOztnSEExTlUsbUJBQW1CLGtCQXdCVixRQUFRLGFBQ1IsV0FBVyxhQUNDLHFCQUFxQjtvSEExQjFDLG1CQUFtQixjQUZsQixNQUFNOzJGQUVQLG1CQUFtQjtrQkFIL0IsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkI7OzBCQXlCYyxNQUFNOzJCQUFDLFFBQVE7OzBCQUNmLE1BQU07MkJBQUMsV0FBVzs7MEJBQ2xCLFFBQVE7OzBCQUFJLE1BQU07MkJBQUMscUJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudFJlZiwgSW5qZWN0LCBJbmplY3RhYmxlLCBQTEFURk9STV9JRCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRE9DVU1FTlQsIGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgY29lcmNlRWxlbWVudCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XHJcbmltcG9ydCB7IGdldFJ0bFNjcm9sbEF4aXNUeXBlLCBSdGxTY3JvbGxBeGlzVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XHJcbmltcG9ydCB7IF9Cb3R0b20sIF9MZWZ0LCBfUmlnaHQsIF9Ub3AsIF9XaXRob3V0IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3Njcm9sbGluZyc7XHJcbmltcG9ydCB7IGZyb21FdmVudCwgbWVyZ2UsIG9mLCBPYnNlcnZhYmxlLCBTdWJqZWN0LCBTdWJzY3JpYmVyLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBleHBhbmQsIGZpbmFsaXplLCB0YWtlLCB0YWtlVW50aWwsIHRha2VXaGlsZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IEJlemllckVhc2luZyBmcm9tICdiZXppZXItZWFzaW5nJztcclxuaW1wb3J0IHtcclxuICBTTU9PVEhfU0NST0xMX09QVElPTlMsXHJcbiAgU21vb3RoU2Nyb2xsRWxlbWVudCxcclxuICBTbW9vdGhTY3JvbGxTdGVwLFxyXG4gIFNtb290aFNjcm9sbFRvRWxlbWVudE9wdGlvbnMsXHJcbiAgU21vb3RoU2Nyb2xsVG9PcHRpb25zXHJcbn0gZnJvbSAnLi9zbW9vdGgtc2Nyb2xsLm1vZGVsJztcclxuXHJcbi8vIEBkeW5hbWljXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCdcclxufSlcclxuZXhwb3J0IGNsYXNzIFNtb290aFNjcm9sbE1hbmFnZXIge1xyXG5cclxuICAvLyBEZWZhdWx0IG9wdGlvbnNcclxuICBwcml2YXRlIHJlYWRvbmx5IF9kZWZhdWx0T3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zO1xyXG5cclxuICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgb25nb2luZyBTbW9vdGhTY3JvbGwgZnVuY3Rpb25zIHNvIHRoZXkgY2FuIGJlIGhhbmRsZWQgaW4gY2FzZSBvZiBkdXBsaWNhdGlvbi5cclxuICAvLyBFYWNoIHNjcm9sbGVkIGVsZW1lbnQgZ2V0cyBhIGRlc3Ryb3llciBzdHJlYW0gd2hpY2ggZ2V0cyBkZWxldGVkIGltbWVkaWF0ZWx5IGFmdGVyIGl0IGNvbXBsZXRlcy5cclxuICAvLyBQdXJwb3NlOiBJZiB1c2VyIGNhbGxlZCBhIHNjcm9sbCBmdW5jdGlvbiBhZ2FpbiBvbiB0aGUgc2FtZSBlbGVtZW50IGJlZm9yZSB0aGUgc2Nyb2xscyBjb21wbGV0ZXMsXHJcbiAgLy8gaXQgY2FuY2VscyB0aGUgb25nb2luZyBzY3JvbGwgYW5kIHN0YXJ0cyBhIG5ldyBvbmVcclxuICBwcml2YXRlIF9vbkdvaW5nU2Nyb2xscyA9IG5ldyBNYXA8SFRNTEVsZW1lbnQsIFN1YmplY3Q8dm9pZD4+KCk7XHJcblxyXG4gIHByaXZhdGUgZ2V0IF93KCk6IFdpbmRvdyB7XHJcbiAgICByZXR1cm4gdGhpcy5fZG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaW1pbmcgbWV0aG9kXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXQgX25vdygpIHtcclxuICAgIHJldHVybiB0aGlzLl93LnBlcmZvcm1hbmNlICYmIHRoaXMuX3cucGVyZm9ybWFuY2Uubm93XHJcbiAgICAgID8gdGhpcy5fdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh0aGlzLl93LnBlcmZvcm1hbmNlKVxyXG4gICAgICA6IERhdGUubm93O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IERvY3VtZW50LFxyXG4gICAgICAgICAgICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgX3BsYXRmb3JtOiBvYmplY3QsXHJcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChTTU9PVEhfU0NST0xMX09QVElPTlMpIGN1c3RvbURlZmF1bHRPcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMpIHtcclxuICAgIHRoaXMuX2RlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgICBkdXJhdGlvbjogNDY4LFxyXG4gICAgICBlYXNpbmc6IHtcclxuICAgICAgICB4MTogMC40MixcclxuICAgICAgICB5MTogMCxcclxuICAgICAgICB4MjogMC41OCxcclxuICAgICAgICB5MjogMVxyXG4gICAgICB9LFxyXG4gICAgICAuLi5jdXN0b21EZWZhdWx0T3B0aW9ucyxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBjaGFuZ2VzIHNjcm9sbCBwb3NpdGlvbiBpbnNpZGUgYW4gZWxlbWVudFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3Njcm9sbEVsZW1lbnQoZWw6IEhUTUxFbGVtZW50LCB4OiBudW1iZXIsIHk6IG51bWJlcik6IHZvaWQge1xyXG4gICAgZWwuc2Nyb2xsTGVmdCA9IHg7XHJcbiAgICBlbC5zY3JvbGxUb3AgPSB5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBhIGdpdmVuIHBhcmFtZXRlciBvZiB0eXBlIEhUTUxFbGVtZW50LCBFbGVtZW50UmVmIG9yIHNlbGVjdG9yXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0RWxlbWVudChlbDogSFRNTEVsZW1lbnQgfCBFbGVtZW50UmVmIHwgc3RyaW5nLCBwYXJlbnQ/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50IHtcclxuICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiAocGFyZW50IHx8IHRoaXMuX2RvY3VtZW50KS5xdWVyeVNlbGVjdG9yKGVsKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb2VyY2VFbGVtZW50PEhUTUxFbGVtZW50PihlbCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplcyBhIGRlc3Ryb3llciBzdHJlYW0sIHJlLWluaXRpYWxpemVzIGl0IGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgc2Nyb2xsZWRcclxuICAgKi9cclxuICBwcml2YXRlIF9pbml0U21vb3RoU2Nyb2xsKGVsOiBIVE1MRWxlbWVudCk6IFN1YmplY3Q8dm9pZD4ge1xyXG4gICAgaWYgKHRoaXMuX29uR29pbmdTY3JvbGxzLmhhcyhlbCkpIHtcclxuICAgICAgdGhpcy5fb25Hb2luZ1Njcm9sbHMuZ2V0KGVsKSEubmV4dCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX29uR29pbmdTY3JvbGxzLnNldChlbCwgbmV3IFN1YmplY3Q8dm9pZD4oKSkhLmdldChlbCkhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHNtb290aCBzY3JvbGwgaGFzIHJlYWNoZWQsIGNsZWFucyB1cCB0aGUgc21vb3RoIHNjcm9sbCBzdHJlYW0gYW5kIHJlc29sdmVzIGl0cyBwcm9taXNlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfaXNGaW5pc2hlZChjb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwLCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4sIHJlc29sdmU6ICgpID0+IHZvaWQpOiBib29sZWFuIHtcclxuICAgIGlmIChjb250ZXh0LmN1cnJlbnRYICE9PSBjb250ZXh0LnggfHwgY29udGV4dC5jdXJyZW50WSAhPT0gY29udGV4dC55KSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveWVkLm5leHQoKTtcclxuICAgIHJlc29sdmUoKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRlcm1pbmF0ZXMgYW4gb25nb2luZyBzbW9vdGggc2Nyb2xsXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfaW50ZXJydXB0ZWQoZWw6IEhUTUxFbGVtZW50LCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4pOiBPYnNlcnZhYmxlPEV2ZW50IHwgdm9pZD4ge1xyXG4gICAgcmV0dXJuIG1lcmdlKFxyXG4gICAgICBmcm9tRXZlbnQoZWwsICd3aGVlbCcsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9KSxcclxuICAgICAgZnJvbUV2ZW50KGVsLCAndG91Y2htb3ZlJywgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pLFxyXG4gICAgICBkZXN0cm95ZWRcclxuICAgICkucGlwZSh0YWtlKDEpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZXMgdGhlIGRlc3Ryb3llciBmdW5jdGlvbiwgcnVucyBpZiB0aGUgc21vb3RoIHNjcm9sbCBoYXMgZmluaXNoZWQgb3IgaW50ZXJydXB0ZWRcclxuICAgKi9cclxuICBwcml2YXRlIF9kZXN0cm95KGVsOiBIVE1MRWxlbWVudCwgZGVzdHJveWVkOiBTdWJqZWN0PHZvaWQ+KTogdm9pZCB7XHJcbiAgICBkZXN0cm95ZWQuY29tcGxldGUoKTtcclxuICAgIHRoaXMuX29uR29pbmdTY3JvbGxzLmRlbGV0ZShlbCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIGZ1bmN0aW9uIGNhbGxlZCByZWN1cnNpdmVseSB0aGF0LCBnaXZlbiBhIGNvbnRleHQsIHN0ZXBzIHRocm91Z2ggc2Nyb2xsaW5nXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfc3RlcChjb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwKTogT2JzZXJ2YWJsZTxTbW9vdGhTY3JvbGxTdGVwPiB7XHJcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8U21vb3RoU2Nyb2xsU3RlcD4pID0+IHtcclxuICAgICAgbGV0IGVsYXBzZWQgPSAodGhpcy5fbm93KCkgLSBjb250ZXh0LnN0YXJ0VGltZSkgLyBjb250ZXh0LmR1cmF0aW9uO1xyXG5cclxuICAgICAgLy8gYXZvaWQgZWxhcHNlZCB0aW1lcyBoaWdoZXIgdGhhbiBvbmVcclxuICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XHJcblxyXG4gICAgICAvLyBhcHBseSBlYXNpbmcgdG8gZWxhcHNlZCB0aW1lXHJcbiAgICAgIGNvbnN0IHZhbHVlID0gY29udGV4dC5lYXNpbmcoZWxhcHNlZCk7XHJcblxyXG4gICAgICBjb250ZXh0LmN1cnJlbnRYID0gY29udGV4dC5zdGFydFggKyAoY29udGV4dC54IC0gY29udGV4dC5zdGFydFgpICogdmFsdWU7XHJcbiAgICAgIGNvbnRleHQuY3VycmVudFkgPSBjb250ZXh0LnN0YXJ0WSArIChjb250ZXh0LnkgLSBjb250ZXh0LnN0YXJ0WSkgKiB2YWx1ZTtcclxuXHJcbiAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQoY29udGV4dC5zY3JvbGxhYmxlLCBjb250ZXh0LmN1cnJlbnRYLCBjb250ZXh0LmN1cnJlbnRZKTtcclxuICAgICAgLy8gUHJvY2VlZCB0byB0aGUgc3RlcFxyXG4gICAgICBhbmltYXRpb25GcmFtZVNjaGVkdWxlci5zY2hlZHVsZSgoKSA9PiBzdWJzY3JpYmVyLm5leHQoY29udGV4dCkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9hcHBseVNjcm9sbFRvT3B0aW9ucyhlbDogSFRNTEVsZW1lbnQsIG9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKCFvcHRpb25zLmR1cmF0aW9uISkge1xyXG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50KGVsLCBvcHRpb25zIS5sZWZ0ISwgb3B0aW9ucyEudG9wISk7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGEgZGVzdHJveWVyIHN0cmVhbSwgcmVpbml0aWFsaXplIGl0IGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgc2Nyb2xsZWRcclxuICAgIGNvbnN0IGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPiA9IHRoaXMuX2luaXRTbW9vdGhTY3JvbGwoZWwpO1xyXG5cclxuICAgIGNvbnN0IGNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXAgPSB7XHJcbiAgICAgIHNjcm9sbGFibGU6IGVsLFxyXG4gICAgICBzdGFydFRpbWU6IHRoaXMuX25vdygpLFxyXG4gICAgICBzdGFydFg6IGVsLnNjcm9sbExlZnQsXHJcbiAgICAgIHN0YXJ0WTogZWwuc2Nyb2xsVG9wLFxyXG4gICAgICB4OiBvcHRpb25zLmxlZnQgPT0gbnVsbCA/IGVsLnNjcm9sbExlZnQgOiB+fm9wdGlvbnMubGVmdCxcclxuICAgICAgeTogb3B0aW9ucy50b3AgPT0gbnVsbCA/IGVsLnNjcm9sbFRvcCA6IH5+b3B0aW9ucy50b3AsXHJcbiAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uISxcclxuICAgICAgZWFzaW5nOiBCZXppZXJFYXNpbmcob3B0aW9ucy5lYXNpbmchLngxISwgb3B0aW9ucy5lYXNpbmchLnkxISwgb3B0aW9ucy5lYXNpbmchLngyISwgb3B0aW9ucy5lYXNpbmchLnkyISlcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAvLyBTY3JvbGwgZWFjaCBzdGVwIHJlY3Vyc2l2ZWx5XHJcbiAgICAgIG9mKG51bGwpLnBpcGUoXHJcbiAgICAgICAgZXhwYW5kKCgpID0+IHRoaXMuX3N0ZXAoY29udGV4dCkucGlwZShcclxuICAgICAgICAgIHRha2VXaGlsZSgoY3VyckNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXApID0+IHRoaXMuX2lzRmluaXNoZWQoY3VyckNvbnRleHQsIGRlc3Ryb3llZCwgcmVzb2x2ZSkpXHJcbiAgICAgICAgKSksXHJcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX2ludGVycnVwdGVkKGVsLCBkZXN0cm95ZWQpKSxcclxuICAgICAgICBmaW5hbGl6ZSgoKSA9PiB0aGlzLl9kZXN0cm95KGVsLCBkZXN0cm95ZWQpKVxyXG4gICAgICApLnN1YnNjcmliZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogU2Nyb2xscyB0byB0aGUgc3BlY2lmaWVkIG9mZnNldHMuIFRoaXMgaXMgYSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIGJyb3dzZXIncyBuYXRpdmUgc2Nyb2xsVG9cclxuICAgKiBtZXRob2QsIHNpbmNlIGJyb3dzZXJzIGFyZSBub3QgY29uc2lzdGVudCBhYm91dCB3aGF0IHNjcm9sbExlZnQgbWVhbnMgaW4gUlRMLiBGb3IgdGhpcyBtZXRob2RcclxuICAgKiBsZWZ0IGFuZCByaWdodCBhbHdheXMgcmVmZXIgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGUgb2YgdGhlIHNjcm9sbGluZyBjb250YWluZXIgaXJyZXNwZWN0aXZlXHJcbiAgICogb2YgdGhlIGxheW91dCBkaXJlY3Rpb24uIHN0YXJ0IGFuZCBlbmQgcmVmZXIgdG8gbGVmdCBhbmQgcmlnaHQgaW4gYW4gTFRSIGNvbnRleHQgYW5kIHZpY2UtdmVyc2FcclxuICAgKiBpbiBhbiBSVEwgY29udGV4dC5cclxuICAgKiBAcGFyYW0gc2Nyb2xsYWJsZSBlbGVtZW50XHJcbiAgICogQHBhcmFtIGN1c3RvbU9wdGlvbnMgc3BlY2lmaWVkIHRoZSBvZmZzZXRzIHRvIHNjcm9sbCB0by5cclxuICAgKi9cclxuICBzY3JvbGxUbyhzY3JvbGxhYmxlOiBTbW9vdGhTY3JvbGxFbGVtZW50LCBjdXN0b21PcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLl9wbGF0Zm9ybSkpIHtcclxuICAgICAgY29uc3QgZWwgPSB0aGlzLl9nZXRFbGVtZW50KHNjcm9sbGFibGUpO1xyXG4gICAgICBjb25zdCBpc1J0bCA9IGdldENvbXB1dGVkU3R5bGUoZWwpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XHJcbiAgICAgIGNvbnN0IHJ0bFNjcm9sbEF4aXNUeXBlID0gZ2V0UnRsU2Nyb2xsQXhpc1R5cGUoKTtcclxuXHJcbiAgICAgIGNvbnN0IG9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucyA9IHtcclxuICAgICAgICAuLi4odGhpcy5fZGVmYXVsdE9wdGlvbnMgYXMgX1dpdGhvdXQ8X0JvdHRvbSAmIF9Ub3A+KSxcclxuICAgICAgICAuLi5jdXN0b21PcHRpb25zLFxyXG4gICAgICAgIC4uLih7XHJcbiAgICAgICAgICAvLyBSZXdyaXRlIHN0YXJ0ICYgZW5kIG9mZnNldHMgYXMgcmlnaHQgb3IgbGVmdCBvZmZzZXRzLlxyXG4gICAgICAgICAgbGVmdDogY3VzdG9tT3B0aW9ucy5sZWZ0ID09IG51bGwgPyAoaXNSdGwgPyBjdXN0b21PcHRpb25zLmVuZCA6IGN1c3RvbU9wdGlvbnMuc3RhcnQpIDogY3VzdG9tT3B0aW9ucy5sZWZ0LFxyXG4gICAgICAgICAgcmlnaHQ6IGN1c3RvbU9wdGlvbnMucmlnaHQgPT0gbnVsbCA/IChpc1J0bCA/IGN1c3RvbU9wdGlvbnMuc3RhcnQgOiBjdXN0b21PcHRpb25zLmVuZCkgOiBjdXN0b21PcHRpb25zLnJpZ2h0XHJcbiAgICAgICAgfSBhcyBfV2l0aG91dDxfQm90dG9tICYgX1RvcD4pXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBSZXdyaXRlIHRoZSBib3R0b20gb2Zmc2V0IGFzIGEgdG9wIG9mZnNldC5cclxuICAgICAgaWYgKG9wdGlvbnMuYm90dG9tICE9IG51bGwpIHtcclxuICAgICAgICAob3B0aW9ucyBhcyBfV2l0aG91dDxfQm90dG9tPiAmIF9Ub3ApLnRvcCA9IGVsLnNjcm9sbEhlaWdodCAtIGVsLmNsaWVudEhlaWdodCAtIG9wdGlvbnMuYm90dG9tO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXdyaXRlIHRoZSByaWdodCBvZmZzZXQgYXMgYSBsZWZ0IG9mZnNldC5cclxuICAgICAgaWYgKGlzUnRsICYmIHJ0bFNjcm9sbEF4aXNUeXBlICE9PSBSdGxTY3JvbGxBeGlzVHlwZS5OT1JNQUwpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5sZWZ0ICE9IG51bGwpIHtcclxuICAgICAgICAgIChvcHRpb25zIGFzIF9XaXRob3V0PF9MZWZ0PiAmIF9SaWdodCkucmlnaHQgPSBlbC5zY3JvbGxXaWR0aCAtIGVsLmNsaWVudFdpZHRoIC0gb3B0aW9ucy5sZWZ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJ0bFNjcm9sbEF4aXNUeXBlID09PSBSdGxTY3JvbGxBeGlzVHlwZS5JTlZFUlRFRCkge1xyXG4gICAgICAgICAgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5yaWdodDtcclxuICAgICAgICB9IGVsc2UgaWYgKHJ0bFNjcm9sbEF4aXNUeXBlID09PSBSdGxTY3JvbGxBeGlzVHlwZS5ORUdBVEVEKSB7XHJcbiAgICAgICAgICBvcHRpb25zLmxlZnQgPSBvcHRpb25zLnJpZ2h0ID8gLW9wdGlvbnMucmlnaHQgOiBvcHRpb25zLnJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5yaWdodCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAob3B0aW9ucyBhcyBfV2l0aG91dDxfUmlnaHQ+ICYgX0xlZnQpLmxlZnQgPSBlbC5zY3JvbGxXaWR0aCAtIGVsLmNsaWVudFdpZHRoIC0gb3B0aW9ucy5yaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2Nyb2xsVG9PcHRpb25zKGVsLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjcm9sbCB0byBlbGVtZW50IGJ5IHJlZmVyZW5jZSBvciBzZWxlY3RvclxyXG4gICAqL1xyXG4gIHNjcm9sbFRvRWxlbWVudChzY3JvbGxhYmxlOiBTbW9vdGhTY3JvbGxFbGVtZW50LCB0YXJnZXQ6IFNtb290aFNjcm9sbEVsZW1lbnQsIGN1c3RvbU9wdGlvbnM6IFNtb290aFNjcm9sbFRvRWxlbWVudE9wdGlvbnMgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3Qgc2Nyb2xsYWJsZUVsID0gdGhpcy5fZ2V0RWxlbWVudChzY3JvbGxhYmxlKTtcclxuICAgIGNvbnN0IHRhcmdldEVsID0gdGhpcy5fZ2V0RWxlbWVudCh0YXJnZXQsIHNjcm9sbGFibGVFbCk7XHJcbiAgICBjb25zdCBvcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMgPSB7XHJcbiAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXHJcbiAgICAgIC4uLntcclxuICAgICAgICBsZWZ0OiB0YXJnZXRFbC5vZmZzZXRMZWZ0ICsgKGN1c3RvbU9wdGlvbnMubGVmdCB8fCAwKSxcclxuICAgICAgICB0b3A6IHRhcmdldEVsLm9mZnNldFRvcCArIChjdXN0b21PcHRpb25zLnRvcCB8fCAwKVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHRhcmdldEVsID8gdGhpcy5zY3JvbGxUbyhzY3JvbGxhYmxlRWwsIG9wdGlvbnMpIDogUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfVxyXG59XHJcbiJdfQ==