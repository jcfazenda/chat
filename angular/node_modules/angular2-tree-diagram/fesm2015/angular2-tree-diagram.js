import { __decorate } from 'tslib';
import { CommonModule } from '@angular/common';
import { Injectable, Input, Component, NgModule } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';

class TreeDiagramNode {
    constructor(props, config, getThisNodeList) {
        this.getThisNodeList = getThisNodeList;
        if (!props.guid) {
            return;
        }
        for (const prop in props) {
            if (props.hasOwnProperty(prop)) {
                this[prop] = props[prop];
            }
        }
        this.toggleState = false;
        if (config.nodeWidth) {
            this.width = config.nodeWidth;
        }
        if (config.nodeHeight) {
            this.height = config.nodeHeight;
        }
        this.children = new Set(props.children);
    }
    get isMaker() {
        return false;
    }
    get isExpanded() {
        return this.toggleState;
    }
    destroy() {
        this.getThisNodeList().destroy(this.guid);
    }
    hasChildren() {
        return !!this.children.size;
    }
    toggle(state = !this.toggleState) {
        this.toggleState = state;
        if (state) {
            this.getThisNodeList().toggleSiblings(this.guid);
        }
    }
    childrenCount() {
        return this.children.size;
    }
    isRoot() {
        return this.parentId == null;
    }
    dragenter(event) {
        event.dataTransfer.dropEffect = 'move';
    }
    dragleave(event) {
        this.isDragover = false;
    }
    dragstart(event) {
        event.dataTransfer.effectAllowed = 'move';
        this.isDragging = true;
        this.toggle(false);
        this.getThisNodeList().draggingNodeGuid = this.guid;
    }
    dragover(event) {
        event.preventDefault();
        if (!this.isDragging) {
            this.isDragover = true;
        }
        event.dataTransfer.dropEffect = 'move';
        return false;
    }
    dragend() {
        this.isDragover = false;
        this.isDragging = false;
    }
    drop(event) {
        event.preventDefault();
        const guid = this.getThisNodeList().draggingNodeGuid;
        this.getThisNodeList().transfer(guid, this.guid);
        return false;
    }
    addChild() {
        const newNodeGuid = this.getThisNodeList().newNode(this.guid);
        this.children.add(newNodeGuid);
        this.toggle(true);
    }
}

class TreeDiagramNodeMaker extends TreeDiagramNode {
    constructor() {
        super(...arguments);
        this.isMakerState = true;
    }
    get isMaker() {
        return this.isMakerState;
    }
    drop(event) {
        event.preventDefault();
        const guid = this.getThisNodeList().draggingNodeGuid;
        this.getThisNodeList().rootNode(guid);
        this.displayName = 'New node';
        return false;
    }
    dragenter(event) {
        event.dataTransfer.dropEffect = 'move';
        const guid = this.getThisNodeList().draggingNodeGuid;
        const node = this.getThisNodeList().getNode(guid);
        if (node.parentId) {
            this.displayName = 'Root';
        }
    }
    dragover(event) {
        event.preventDefault();
        const guid = this.getThisNodeList().draggingNodeGuid;
        const node = this.getThisNodeList().getNode(guid);
        if (!this.isDragging && node.parentId) {
            this.isDragover = true;
            event.dataTransfer.dropEffect = 'move';
        }
        return false;
    }
    dragleave(event) {
        this.displayName = 'New node';
        this.isDragover = false;
    }
}

class TreeDiagramNodesList {
    constructor(nodes, config) {
        this.config = config;
        this.nodeTemplate = {
            displayName: 'New node',
            children: [],
            guid: '',
            parentId: null
        };
        this.nodesList = new Map();
        nodes.forEach(treeNode => {
            this.nodesList.set(treeNode.guid, new TreeDiagramNode(treeNode, config, this.getThisNodeList.bind(this)));
        });
        this.makeRoots();
        this.makerGuid = this.uuidv4();
        const node = {
            guid: this.makerGuid,
            parentId: 'root',
            children: [],
            displayName: 'New node'
        };
        const maker = new TreeDiagramNodeMaker(node, this.config, this.getThisNodeList.bind(this));
        this.nodesList.set(this.makerGuid, maker);
    }
    values() {
        return this.nodesList.values();
    }
    getNode(guid) {
        return this.nodesList.get(guid);
    }
    rootNode(guid) {
        const node = this.getNode(guid);
        const maker = this.getNode(this.makerGuid);
        node.isDragging = false;
        node.isDragover = false;
        if (node.parentId) {
            const parent = this.getNode(node.parentId);
            parent.children.delete(guid);
        }
        node.parentId = null;
        this.makeRoots();
        maker.isDragging = false;
        maker.isDragover = false;
    }
    transfer(originId, targetId) {
        const origin = this.getNode(originId);
        const target = this.getNode(targetId);
        origin.isDragover = false;
        origin.isDragging = false;
        target.isDragover = false;
        if (origin.parentId === targetId || originId === targetId) {
            return;
        }
        const remakeRoots = origin.isRoot();
        if (origin.parentId) {
            const parent = this.getNode(origin.parentId);
            parent.children.delete(originId);
            if (!parent.hasChildren()) {
                parent.toggle(false);
            }
        }
        target.children.add(originId);
        origin.parentId = targetId;
        if (remakeRoots) {
            this.makeRoots();
        }
        this.serialize();
    }
    getThisNodeList() {
        return this;
    }
    toggleSiblings(guid) {
        const target = this.getNode(guid);
        if (target.parentId) {
            const parent = this.getNode(target.parentId);
            parent.children.forEach(nodeGuid => {
                if (nodeGuid === guid) {
                    return;
                }
                this.getNode(nodeGuid).toggle(false);
            });
        }
        else {
            for (const root of this.roots) {
                if (root.guid === guid) {
                    continue;
                }
                root.toggle(false);
            }
        }
    }
    serialize() {
        const out = [];
        this.nodesList.forEach((node) => {
            const json = {
                guid: node.guid,
                displayName: node.displayName,
                parentId: node.parentId,
                children: Array.from(node.children),
            };
            out.push(json);
        });
        return out;
    }
    destroy(guid) {
        const target = this.getNode(guid);
        if (target.parentId) {
            const parent = this.getNode(target.parentId);
            parent.children.delete(guid);
        }
        if (target.hasChildren()) {
            target.children.forEach((child) => {
                this.nodesList.delete(child);
            });
        }
        this.nodesList.delete(guid);
    }
    newNode(parentId = null) {
        const nodeTemplate = Object.assign({}, this.nodeTemplate);
        nodeTemplate.guid = this.uuidv4();
        nodeTemplate.parentId = parentId;
        this.nodesList.set(nodeTemplate.guid, new TreeDiagramNode(nodeTemplate, this.config, this.getThisNodeList.bind(this)));
        this.makeRoots();
        return nodeTemplate.guid;
    }
    uuidv4() {
        // tslint:disable-next-line:only-arrow-functions
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            // tslint:disable-next-line:one-variable-per-declaration no-bitwise
            const r = (Math.random() * 16) | 0, 
            // tslint:disable-next-line:triple-equals no-bitwise
            v = c == 'x' ? r : (r & 0x3) | 0x8;
            return v.toString(16);
        });
    }
    makeRoots() {
        this.roots = Array.from(this.values()).filter((node) => node.isRoot());
    }
}

let NodesListService = class NodesListService {
    loadNodes(nodes, config) {
        this.nodesList = new TreeDiagramNodesList(nodes, config);
        return this.nodesList;
    }
    getNode(guid) {
        return this.nodesList.getNode(guid);
    }
    newNode() {
        this.nodesList.newNode();
    }
    makerNode() {
        return this.nodesList.makerGuid;
    }
    toJsonString() {
        return JSON.stringify(this.nodesList.serialize());
    }
};
NodesListService = __decorate([
    Injectable()
], NodesListService);

let TreeComponent = class TreeComponent {
    constructor(nodesSrv, sanitizer) {
        this.nodesSrv = nodesSrv;
        this.sanitizer = sanitizer;
        this.config = {
            nodeWidth: 200,
            nodeHeight: 100
        };
        this.paneDragging = false;
        this.zoom = 1;
        this.paneX = 0;
        this.paneY = 0;
    }
    get paneTransform() {
        return this.paneTransformState;
    }
    set paneTransform(value) {
        this.paneTransformState = value;
    }
    set data(data) {
        if (!data || !Array.isArray(data.json)) {
            return;
        }
        if (typeof data.config === 'object') {
            this.config = Object.assign(this.config, data.config);
        }
        this.nodes = this.nodesSrv.loadNodes(data.json, this.config);
    }
    get nodeMaker() {
        return this.nodesSrv.makerNode();
    }
    newNode() {
        this.nodesSrv.newNode();
    }
    onmousedown() {
        this.paneDragging = true;
    }
    onmousemove(event) {
        if (this.paneDragging) {
            const { movementX, movementY } = event;
            this.paneX += movementX;
            this.paneY += movementY;
            this.makeTransform();
        }
    }
    onmouseup() {
        this.paneDragging = false;
    }
    makeTransform() {
        this.paneTransform = this.sanitizer.bypassSecurityTrustStyle(`translate(${this.paneX}px, ${this.paneY}px) scale(${this.zoom})`);
    }
    preventMouse(event) {
        event.stopPropagation();
    }
    onmousewheel(event) {
        let delta;
        event.preventDefault();
        delta = event.detail || event.wheelDelta;
        this.zoom += delta / 1000 / 2;
        this.zoom = Math.min(Math.max(this.zoom, 0.2), 3);
        this.makeTransform();
    }
};
TreeComponent.ctorParameters = () => [
    { type: NodesListService },
    { type: DomSanitizer }
];
__decorate([
    Input()
], TreeComponent.prototype, "data", null);
TreeComponent = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'tree-diagram',
        template: "<div\n  class=\"tree-pane\"\n  (mousedown)=\"onmousedown()\"\n  (mouseup)=\"onmouseup()\"\n  (mousemove)=\"onmousemove($event)\"\n  (mousewheel)=\"onmousewheel($event)\"\n>\n  <div class=\"tree-paning-container\" [style.transform]=\"paneTransform\">\n    <div *ngIf=\"nodes\" class=\"tree-roots-elements\">\n\n      <tree-diagram-node\n        [nodeId]=\"node.guid\"\n        class=\"tree-root tree-node\"\n        (mousedown)=\"preventMouse($event)\"\n        *ngFor=\"let node of nodes.roots\"\n      ></tree-diagram-node>\n\n      <tree-diagram-node\n        [nodeId]=\"nodeMaker\"\n        (click)=\"newNode()\"\n        (mousedown)=\"preventMouse($event)\"\n        class=\"tree-root tree-new-node tree-node\"\n      ></tree-diagram-node>\n\n    </div>\n  </div>\n</div>\n",
        styles: [":host{-webkit-print-color-adjust:exact;position:relative;display:block;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;overflow:hidden;height:100vh;text-align:center}.tree-roots-elements{position:relative;text-align:center;display:inline-block;white-space:nowrap;cursor:default!important;font-size:0;-webkit-transform-origin:center;transform-origin:center}.tree-node{position:relative;display:inline-block;margin:15px;vertical-align:top}.tree-node:only-of-type>.line-to{display:none}.tree-pane,.tree-paning-container{position:absolute;left:0;top:0;right:0;bottom:0}"]
    })
], TreeComponent);

let NodeComponent = class NodeComponent {
    constructor(nodesSrv, sanitizer) {
        this.nodesSrv = nodesSrv;
        this.sanitizer = sanitizer;
        this.isRtl = document.getElementsByTagName('html')[0].getAttribute('dir') === 'rtl';
    }
    set nodeId(guid) {
        this.node = this.nodesSrv.getNode(guid);
        let calculation = `translate(calc(-50% + ${Math.round(this.node.width / 2)}px), 45px)`;
        if (this.isRtl) {
            calculation = `translate(calc(50% - ${Math.round(this.node.width / 2)}px), 45px)`;
        }
        this.childrenTransform = this.sanitizer.bypassSecurityTrustStyle(calculation);
    }
    onNodeBlur(event, nodeId) {
        const node = this.nodesSrv.getNode(nodeId);
        node.displayName = event.target.innerText;
    }
};
NodeComponent.ctorParameters = () => [
    { type: NodesListService },
    { type: DomSanitizer }
];
__decorate([
    Input()
], NodeComponent.prototype, "nodeId", null);
NodeComponent = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'tree-diagram-node',
        template: "<div class=\"line-to\"></div>\n<div\n  id=\"tree-node-{{ node.guid }}\"\n  [ngClass]=\"{\n    'tree-element-container': !0,\n    'tree-element-has-children': node.hasChildren()\n  }\"\n  [style.width.px]=\"node.width\"\n  [style.height.px]=\"node.height\"\n>\n  <div\n    [ngClass]=\"{\n      'tree-element-main': !0,\n      dragover: node.isDragover,\n      expanded: node.isExpanded,\n      dragging: node.isDragging,\n      'tree-new-node': node.isMaker\n    }\"\n    [attr.draggable]=\"node.isMaker ? null : 'true'\"\n    [style.width.px]=\"node.width\"\n    [style.height.px]=\"node.height\"\n    (drop)=\"node.drop($event)\"\n    (dragenter)=\"node.dragenter($event)\"\n    (dragstart)=\"node.dragstart($event)\"\n    (dragover)=\"node.dragover($event)\"\n    (dragend)=\"node.dragend()\"\n    (dragleave)=\"node.dragleave($event)\"\n  >\n    <div\n      class=\"rect\"\n      [style.width.px]=\"node.width\"\n      [style.height.px]=\"node.height\"\n    >\n      <div class=\"buttons\">\n        <div class=\"delete\" (click)=\"node.destroy()\"></div>\n        <div class=\"toggler\" (click)=\"node.toggle()\"></div>\n        <div class=\"add\" (click)=\"node.addChild()\"></div>\n      </div>\n      <div class=\"tree-text tree-text-non-editable\">\n        <span>{{ node.displayName }}</span>\n      </div>\n      <div class=\"tree-text tree-text-editable\">\n        <span\n          contenteditable\n          [innerHtml]=\"node.displayName\"\n          (blur)=\"onNodeBlur($event, node.guid)\"\n        ></span>\n        <span class=\"children-count\"> ({{ node.childrenCount() }})</span>\n      </div>\n    </div>\n  </div>\n  <div\n    class=\"tree-children\"\n    [style.transform]=\"childrenTransform\"\n    *ngIf=\"node.isExpanded\"\n  >\n    <div class=\"tree-elements-group\">\n      <tree-diagram-node\n        *ngFor=\"let child of node.children\"\n        [nodeId]=\"child\"\n        class=\"tree-node tree-child\"\n      ></tree-diagram-node>\n    </div>\n  </div>\n</div>\n",
        styles: [".toggler{position:absolute;left:0;right:0;bottom:-10px;background:#2c4c63;margin:0 auto;display:none;z-index:10;width:20px;height:20px;cursor:pointer;border-radius:2px}.children-count{display:none}.tree-element-has-children>.tree-element-main .toggler{display:block}.tree-element-has-children>.tree-element-main .children-count{display:inline}.tree-element-has-children>.tree-children{display:inline-block}.rect{position:relative;background-color:#fafafa!important;border:1px solid #dadada;box-sizing:border-box;-webkit-print-color-adjust:exact;cursor:default!important;display:-webkit-box;display:flex;-webkit-box-pack:center;justify-content:center;-webkit-box-align:center;align-items:center;font-size:15px;border-radius:2px}.tree-element-main{text-align:center;margin:0 auto}.tree-element-main:hover .buttons{display:block}.tree-element-main.expanded .rect{background-color:#bce5ff!important}.tree-element-main.expanded .toggler{-webkit-transform:rotateZ(-45deg);transform:rotateZ(-45deg);background:#427396}.tree-element-main.dragover .rect{box-shadow:0 0 5px #427396}.tree-element-main.dragging .buttons,.tree-element-main.dragging .tree-node:before{display:none!important}.tree-element-container{z-index:100}.tree-children{text-align:center;display:inline-block;position:relative;white-space:nowrap;-webkit-perspective:3000px;perspective:3000px;-webkit-perspective-origin:center bottom;perspective-origin:center bottom}.tree-children:before{content:\"\";width:calc(50% - 1px);position:absolute;height:30px;left:0;top:-45px;border-right:1px solid #dadada;max-width:100%;max-height:100%}.line-to{position:absolute;top:-30px;border-top:1px solid #dadada;width:calc(100% + 30px);display:none}.tree-node{position:relative;display:inline-block;margin:15px;vertical-align:top}.tree-node:before{content:\"\";width:calc(50% - 1px);position:absolute;height:30px;left:0;top:-30px;border-right:1px solid #dadada}.tree-node:only-of-type>.line-to{display:none!important}.buttons{position:absolute;top:0;left:0;right:0;bottom:0;display:none}.buttons .delete{width:20px;height:20px;cursor:pointer;border-radius:2px;background-color:#a34851;position:absolute;right:-10px;top:-10px}.buttons .add{width:20px;height:20px;cursor:pointer;border-radius:2px;background-color:#256947;position:absolute;right:-10px;bottom:-10px}.buttons .add:before{content:\"\";position:absolute;height:12px;width:4px;top:0;left:0;right:0;bottom:0;margin:auto;background-color:#2ba423}.buttons .add:after{content:\"\";position:absolute;width:12px;height:4px;top:0;left:0;right:0;bottom:0;margin:auto;background-color:#2ba423}.tree-text{z-index:10;white-space:pre-line}.tree-text span{cursor:pointer}.tree-elements-group{position:relative}.tree-elements-group>.tree-node.tree-child>.line-to{left:0;display:block}.tree-elements-group>.tree-node.tree-child:first-of-type>.line-to{right:-30px;width:calc(50% + 30px);display:block;left:auto}.tree-elements-group>.tree-node.tree-child:last-of-type>.line-to{left:0;right:auto;width:50%;display:block}.tree-elements-group>.tree-node.tree-child>.tree-child:last-child{margin-right:0}.tree-elements-group>.tree-node.tree-child>.tree-child:first-child{margin-left:0}.tree-text-non-editable{display:none}.tree-new-node .rect{opacity:.5;border:1px dashed #dadada;cursor:pointer!important}.tree-new-node.dragover .rect,.tree-new-node:hover .rect{opacity:1}.tree-new-node .buttons,.tree-new-node .tree-children{display:none!important}.tree-new-node .tree-text-non-editable{display:block}.tree-new-node .tree-text-editable{display:none}"]
    })
], NodeComponent);

let TreeDiagramModule = class TreeDiagramModule {
};
TreeDiagramModule = __decorate([
    NgModule({
        declarations: [
            TreeComponent,
            NodeComponent
        ],
        imports: [
            CommonModule
        ],
        exports: [
            TreeComponent,
            NodeComponent
        ],
        providers: [
            NodesListService
        ]
    })
], TreeDiagramModule);

/*
 * Public API Surface of ng-tree-diagram
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NodeComponent, NodesListService, TreeDiagramModule, TreeDiagramNode, TreeDiagramNodeMaker, TreeDiagramNodesList, TreeComponent as ɵa };
//# sourceMappingURL=angular2-tree-diagram.js.map
